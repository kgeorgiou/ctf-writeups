**Name**: Inspector Gadget  
**Points**: 400  
**Instructions**: Exploit the vulnerable inspector-gadget service running at challenges.runesec.com:22417.  
**Hint**: And now you'll be telling stories of my return and they won't be false, and they won't be true but they'll be real  

## Exploration
- `$ strings inspector-gadget` doesn't reveal much.
- Running the binary: Prompts for input, then prints "Answer: LOL!!" and starts a `gdbserver`.
- `$ r2 inspector-gadget` reveals nothing that could lead us to the flag; however, the following 2 lines give us a *Christmas-came-early* moment:
```
0x080485b3 68a4860408 push str.gdbserver_:65488_inspector_gadget ; str.gdbserver_:65488_inspector_gadget ; "gdbserver :65488 inspector-gadget" @ 0x80486a4  
0x080485b8 e833feffff call sym.imp.system ;[9]
```  

- That's a system call. Maybe we can replace the system call to gdbserver with something else that can lead us closer to the flag. But this system call, of course, should take place on their server, not our machine.  
- We connect to the service running on their server. Same as locally, we get prompted to give an input and then the `gdbserver` is started, on their server. We can connect to it.
```
$ gdb inspector-gadget
gdb> target remote ctf.challenges.com:65488
``` 
- Brainstorming. 
  - The flag must be somewhere on the remote server.
  - Maybe we can load a symbols table from an external file that resides on the server.
  - That system call that's available to us is too powerful to be ignored.
  - Maybe we can directly access files on the remote filesystem.

## Exploitation
Let's overwrite that system call from  
`gdbserver :65488 inspector-gadget`  
to something short and simple:  
`ls;`

The string `gdbserver :65488 inspector-gadget` is at memory location `0x80486a4`.

We can overwrite it like so:
```
gdb> set {int}0x80486a4 = 0x3B736C
gdb> continue
```  
*0x3B736C is the hex representation of `ls;`, reversed.*  

It works! On the opened session we have to their server it prints:
`flag.txt inspector-gadget` and one more file, but our eyes are staring at `flag.txt`. We must capture it.  

We start thinking about crafting a (short) system call to get the contents of `flag.txt`. `cat *;` maybe?  

Midway of thinking of byte sequences that would make the system call reveal the contents of `flag.txt`, we recall an interesting command for `gdb`:

```
gdb> remote get flag.txt flag.local
```

*Cue the drum roll*   

```
$ cat flag.local
flag{82ef8b2e007da38b9ce1547cd249f6bd}
```
